<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Royal Match">
    <title>Royal Match - Help The King!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #1a0a3e 0%, #2d1b69 50%, #1a0a3e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        h1 {
            color: #ffd700;
            font-size: 1.8em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-info {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .info-box {
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 8px 20px;
            text-align: center;
            min-width: 100px;
        }

        .info-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .king-panel {
            background: linear-gradient(180deg, rgba(60,30,30,0.9), rgba(30,15,15,0.9));
            border: 3px solid #8B0000;
            border-radius: 15px;
            padding: 10px;
            position: relative;
            box-shadow: 0 0 20px rgba(255,0,0,0.3), inset 0 0 30px rgba(0,0,0,0.5);
        }

        .king-panel canvas {
            border-radius: 10px;
            display: block;
        }

        .danger-label {
            color: #ff4444;
            font-size: 0.8em;
            text-align: center;
            margin-top: 5px;
            text-shadow: 0 0 10px #ff0000;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .rescue-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 8px;
        }

        .rescue-progress {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff9500);
            width: 0%;
            transition: width 0.3s;
            border-radius: 5px;
            box-shadow: 0 0 10px #ffd700;
        }

        #gameCanvas {
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.5), inset 0 0 60px rgba(0,0,0,0.3);
            background: linear-gradient(180deg, #2a1a5e, #1a0a3e);
            touch-action: none;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(180deg, #ffd700, #ff9500);
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            color: #1a0a3e;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            min-height: 50px;
            touch-action: manipulation;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .btn.secondary {
            background: linear-gradient(180deg, #8a2be2, #6a1bb2);
            color: #fff;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .level-complete {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        .level-complete.show {
            display: flex;
        }

        .level-complete h2 {
            color: #ffd700;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .level-complete p {
            color: #fff;
            font-size: 1.3em;
            margin-bottom: 20px;
        }

        .stars {
            font-size: 3em;
            margin-bottom: 20px;
        }

        @media (max-width: 450px) {
            h1 { font-size: 1.3em; }
            .info-box { padding: 6px 12px; min-width: 70px; }
            .info-value { font-size: 1em; }
            .king-speech { font-size: 0.8em; min-width: 120px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üëë Royal Match üëë</h1>
    </div>

    <div class="game-info">
        <div class="info-box">
            <div class="info-label">Level</div>
            <div class="info-value" id="level">1</div>
        </div>
        <div class="info-box">
            <div class="info-label">Score</div>
            <div class="info-value" id="score">0</div>
        </div>
        <div class="info-box">
            <div class="info-label">Moves</div>
            <div class="info-value" id="moves">20</div>
        </div>
        <div class="info-box">
            <div class="info-label">Target</div>
            <div class="info-value" id="target">1000</div>
        </div>
    </div>

    <div class="game-area">
        <div class="king-panel">
            <canvas id="kingCanvas" width="200" height="120"></canvas>
            <div class="danger-label" id="dangerLabel">‚ö†Ô∏è DANGER! Save the King! ‚ö†Ô∏è</div>
            <div class="rescue-bar"><div class="rescue-progress" id="rescueProgress"></div></div>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <div class="buttons">
        <button class="btn" onclick="resetLevel()">Restart</button>
        <button class="btn secondary" onclick="newGame()">New Game</button>
    </div>

    <div class="level-complete" id="levelComplete">
        <h2>üëë King Rescued! üëë</h2>
        <div class="stars" id="stars">‚≠ê‚≠ê‚≠ê</div>
        <p id="levelScore">Score: 0</p>
        <button class="btn" onclick="nextLevel()">Save Next King!</button>
    </div>

    <div class="level-complete" id="loseOverlay" style="background: rgba(50,0,0,0.9);">
        <h2 style="color: #ff4444;">üíÄ The King Died! üíÄ</h2>
        <p style="color: #aaa;">The traps got him...</p>
        <button class="btn" onclick="resetLevel()">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const kingCanvas = document.getElementById('kingCanvas');
        const kingCtx = kingCanvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 8;
        const GEM_SIZE = 48;
        const PADDING = 4;
        const BOARD_OFFSET = 8;

        // Gem types
        const GEM_TYPES = [
            { color: '#ff4757', gradient: ['#ff6b7a', '#ff2f44'], shape: 'diamond' },
            { color: '#2ed573', gradient: ['#5fe094', '#1fb854'], shape: 'circle' },
            { color: '#3498db', gradient: ['#5dade2', '#2980b9'], shape: 'square' },
            { color: '#f39c12', gradient: ['#f5b041', '#d68910'], shape: 'triangle' },
            { color: '#9b59b6', gradient: ['#af7ac5', '#7d3c98'], shape: 'hexagon' },
            { color: '#1abc9c', gradient: ['#48c9b0', '#17a589'], shape: 'star' }
        ];

        // Game state
        let grid = [];
        let selectedGem = null;
        let score = 0;
        let moves = 20;
        let level = 1;
        let targetScore = 1000;
        let animating = false;
        let particles = [];
        let floatingTexts = [];
        let kingMood = 'normal'; // normal, happy, excited, worried
        let lastCombo = 0;

        // Hazard system (lava, water, or quicksand)
        let hazardLevel = 0; // How many rows from bottom are covered
        let hazardAnimTime = 0;
        let targetHazardLevel = 0; // Target level (rises on bad swaps)
        let hazardType = 'lava'; // 'lava', 'water', or 'quicksand'

        // King expressions
        const kingPhrases = {
            start: ["Help! I'm trapped!", "Free me!", "Match to rescue me!"],
            match: ["Keep going!", "Almost there!", "You can do it!"],
            combo: ["Amazing!", "I feel hope!", "The bars shake!"],
            bigMatch: ["Incredible!", "I see light!", "Freedom awaits!"],
            lowMoves: ["Hurry please!", "Not much time!", "I'm scared!"],
            win: ["I'm FREE!", "Thank you!", "My hero!"],
            lose: ["Oh no...", "Try again!", "Don't give up!"]
        };

        function init() {
            createGrid();
            removeInitialMatches();
            drawKing();
            draw();
        }

        function createGrid() {
            grid = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    grid[row][col] = {
                        type: Math.floor(Math.random() * GEM_TYPES.length),
                        x: col * GEM_SIZE + BOARD_OFFSET,
                        y: row * GEM_SIZE + BOARD_OFFSET,
                        targetY: row * GEM_SIZE + BOARD_OFFSET,
                        scale: 1,
                        special: null
                    };
                }
            }
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                hasMatches = false;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (checkMatchAt(row, col)) {
                            grid[row][col].type = Math.floor(Math.random() * GEM_TYPES.length);
                            hasMatches = true;
                        }
                    }
                }
            }
        }

        function checkMatchAt(row, col) {
            const type = grid[row][col].type;
            let hCount = 1;
            for (let c = col - 1; c >= 0 && grid[row][c].type === type; c--) hCount++;
            for (let c = col + 1; c < GRID_SIZE && grid[row][c].type === type; c++) hCount++;
            let vCount = 1;
            for (let r = row - 1; r >= 0 && grid[r][col].type === type; r--) vCount++;
            for (let r = row + 1; r < GRID_SIZE && grid[r][col].type === type; r++) vCount++;
            return hCount >= 3 || vCount >= 3;
        }

        let rescued = false;
        let kingDead = false;
        let dangerTime = 0;
        let swordY = -30;
        let monsterX = -40;
        let lavaHeight = 0;
        let spikeY = -20;
        let maxMoves = 20;
        let shakeAmount = 0;

        function drawKing() {
            kingCtx.clearRect(0, 0, kingCanvas.width, kingCanvas.height);
            dangerTime += 0.05;

            // Calculate danger based on moves remaining (not score)
            const movesUsed = maxMoves - moves;
            const danger = Math.min(1, movesUsed / maxMoves);

            // Screen shake when danger is high
            let offsetX = 0, offsetY = 0;
            if (danger > 0.7 && !rescued && !kingDead) {
                shakeAmount = Math.sin(dangerTime * 20) * (danger - 0.7) * 8;
                offsetX = shakeAmount;
            }

            kingCtx.save();
            kingCtx.translate(offsetX, offsetY);

            // Dark dungeon background
            const bgGrad = kingCtx.createLinearGradient(0, 0, 0, kingCanvas.height);
            bgGrad.addColorStop(0, '#1a1a2a');
            bgGrad.addColorStop(1, '#0a0a15');
            kingCtx.fillStyle = bgGrad;
            kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);

            // Stone wall texture
            kingCtx.fillStyle = '#333';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 5; j++) {
                    kingCtx.fillRect(i * 26 + (j % 2) * 13, j * 26, 24, 24);
                }
            }

            const kingX = kingCanvas.width / 2;
            const kingY = 75;

            if (kingDead) {
                // GAME OVER - traps got the King!

                // Full lava
                const lavaGrad = kingCtx.createLinearGradient(0, 40, 0, kingCanvas.height);
                lavaGrad.addColorStop(0, '#ff4500');
                lavaGrad.addColorStop(1, '#8B0000');
                kingCtx.fillStyle = lavaGrad;
                kingCtx.fillRect(0, 40, kingCanvas.width, kingCanvas.height);

                // Bubbling intensely
                kingCtx.fillStyle = '#ff6600';
                for (let i = 0; i < 10; i++) {
                    const bx = Math.random() * kingCanvas.width;
                    const by = 40 + Math.random() * 30;
                    kingCtx.beginPath();
                    kingCtx.arc(bx, by, 3 + Math.random() * 5, 0, Math.PI * 2);
                    kingCtx.fill();
                }

                // Spikes all the way down
                kingCtx.fillStyle = '#666';
                for (let i = 0; i < 7; i++) {
                    kingCtx.beginPath();
                    kingCtx.moveTo(i * 30 + 15, 0);
                    kingCtx.lineTo(i * 30 + 25, 40);
                    kingCtx.lineTo(i * 30 + 5, 40);
                    kingCtx.closePath();
                    kingCtx.fill();
                }

                // Monsters celebrating
                drawMonster(50, 20, false, true);
                drawMonster(120, 25, true, true);

                // Crown floating in lava
                kingCtx.fillStyle = '#FFD700';
                kingCtx.beginPath();
                const crownY = 50 + Math.sin(dangerTime * 2) * 3;
                kingCtx.moveTo(kingX - 8, crownY);
                kingCtx.lineTo(kingX - 6, crownY - 12);
                kingCtx.lineTo(kingX - 3, crownY - 6);
                kingCtx.lineTo(kingX, crownY - 15);
                kingCtx.lineTo(kingX + 3, crownY - 6);
                kingCtx.lineTo(kingX + 6, crownY - 12);
                kingCtx.lineTo(kingX + 8, crownY);
                kingCtx.closePath();
                kingCtx.fill();

                // Skull where king was
                kingCtx.fillStyle = '#ddd';
                kingCtx.beginPath();
                kingCtx.arc(kingX, 70, 12, 0, Math.PI * 2);
                kingCtx.fill();
                kingCtx.fillStyle = '#000';
                kingCtx.beginPath();
                kingCtx.arc(kingX - 4, 67, 3, 0, Math.PI * 2);
                kingCtx.arc(kingX + 4, 67, 3, 0, Math.PI * 2);
                kingCtx.fill();
                kingCtx.beginPath();
                kingCtx.moveTo(kingX - 3, 75);
                kingCtx.lineTo(kingX + 3, 75);
                kingCtx.lineTo(kingX + 3, 78);
                kingCtx.lineTo(kingX + 1, 78);
                kingCtx.lineTo(kingX + 1, 76);
                kingCtx.lineTo(kingX - 1, 76);
                kingCtx.lineTo(kingX - 1, 78);
                kingCtx.lineTo(kingX - 3, 78);
                kingCtx.closePath();
                kingCtx.fill();

                // Dark overlay
                kingCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);

                document.getElementById('dangerLabel').textContent = 'üíÄ THE KING IS DEAD! üíÄ';
                document.getElementById('dangerLabel').style.color = '#ff0000';

            } else if (!rescued) {
                // Rising lava from bottom - based on moves used
                lavaHeight = 10 + (50 * danger) + Math.sin(dangerTime * 2) * 3;
                const lavaGrad = kingCtx.createLinearGradient(0, kingCanvas.height - lavaHeight, 0, kingCanvas.height);
                lavaGrad.addColorStop(0, '#ff4500');
                lavaGrad.addColorStop(0.5, '#ff0000');
                lavaGrad.addColorStop(1, '#8B0000');
                kingCtx.fillStyle = lavaGrad;
                kingCtx.fillRect(0, kingCanvas.height - lavaHeight, kingCanvas.width, lavaHeight);

                // Lava bubbles - more when danger is high
                kingCtx.fillStyle = '#ff6600';
                const bubbleCount = 3 + Math.floor(danger * 7);
                for (let i = 0; i < bubbleCount; i++) {
                    const bx = 20 + i * (180 / bubbleCount) + Math.sin(dangerTime + i) * 5;
                    const by = kingCanvas.height - lavaHeight + Math.sin(dangerTime * 3 + i) * 5;
                    kingCtx.beginPath();
                    kingCtx.arc(bx, by, 3 + Math.sin(dangerTime + i) * 2 + danger * 3, 0, Math.PI * 2);
                    kingCtx.fill();
                }

                // Falling swords from top - closer as danger increases
                swordY = -20 + (50 * danger) + Math.sin(dangerTime * 1.5) * 8;
                drawSword(25, swordY, 0.7);
                drawSword(175, swordY + 5, 0.7);

                // Spikes from ceiling - descending
                spikeY = -15 + (35 * danger) + Math.sin(dangerTime * 2) * 5;
                kingCtx.fillStyle = '#555';
                for (let i = 0; i < 7; i++) {
                    kingCtx.beginPath();
                    kingCtx.moveTo(i * 30 + 15, spikeY);
                    kingCtx.lineTo(i * 30 + 25, spikeY + 30);
                    kingCtx.lineTo(i * 30 + 5, spikeY + 30);
                    kingCtx.closePath();
                    kingCtx.fill();
                }
                kingCtx.fillStyle = '#777';
                for (let i = 0; i < 7; i++) {
                    kingCtx.beginPath();
                    kingCtx.moveTo(i * 30 + 15, spikeY);
                    kingCtx.lineTo(i * 30 + 18, spikeY + 18);
                    kingCtx.lineTo(i * 30 + 12, spikeY + 18);
                    kingCtx.closePath();
                    kingCtx.fill();
                }

                // Monsters approaching - trying to break in!
                monsterX = -30 + (70 * danger) + Math.sin(dangerTime) * 5;

                // Left monster banging on wall
                drawMonster(monsterX, 55, false, false, danger > 0.5);

                // Right monster trying to get in
                drawMonster(kingCanvas.width - monsterX - 30, 60, true, false, danger > 0.6);

                // Cracks in the walls when monsters bang
                if (danger > 0.5) {
                    kingCtx.strokeStyle = '#222';
                    kingCtx.lineWidth = 2;
                    // Left cracks
                    kingCtx.beginPath();
                    kingCtx.moveTo(monsterX + 35, 50);
                    kingCtx.lineTo(monsterX + 45, 60);
                    kingCtx.lineTo(monsterX + 40, 75);
                    kingCtx.stroke();
                    // Right cracks
                    kingCtx.beginPath();
                    kingCtx.moveTo(kingCanvas.width - monsterX - 35, 55);
                    kingCtx.lineTo(kingCanvas.width - monsterX - 45, 65);
                    kingCtx.lineTo(kingCanvas.width - monsterX - 40, 80);
                    kingCtx.stroke();
                }

                // Draw the King (scared!)
                drawKingCharacter(kingX, kingY, 0.55, danger);

                // Warning flashes when danger is high
                if (danger > 0.8) {
                    const flash = Math.sin(dangerTime * 10) > 0 ? 0.2 : 0;
                    kingCtx.fillStyle = `rgba(255, 0, 0, ${flash})`;
                    kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);
                }

                // Update danger label based on danger level
                if (danger > 0.8) {
                    document.getElementById('dangerLabel').textContent = 'üî• CRITICAL! SAVE HIM NOW! üî•';
                } else if (danger > 0.5) {
                    document.getElementById('dangerLabel').textContent = '‚ö†Ô∏è HURRY! Traps closing in! ‚ö†Ô∏è';
                } else {
                    document.getElementById('dangerLabel').textContent = '‚ö†Ô∏è DANGER! Save the King! ‚ö†Ô∏è';
                }
                document.getElementById('dangerLabel').style.color = danger > 0.7 ? '#ff0000' : '#ff4444';

            } else {
                // RESCUED! Victory scene

                // Draw the King (happy!)
                drawKingCharacter(kingX, kingY, 0.55, 0, true);

                // Victory glow
                kingCtx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(dangerTime * 3) * 0.1})`;
                kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);

                // Sparkles everywhere
                kingCtx.fillStyle = '#fff';
                for (let i = 0; i < 12; i++) {
                    const sx = Math.sin(dangerTime * 2 + i * 0.5) * 90 + 100;
                    const sy = Math.cos(dangerTime * 2 + i * 0.5) * 50 + 60;
                    const size = 2 + Math.sin(dangerTime * 3 + i) * 1;
                    kingCtx.beginPath();
                    kingCtx.arc(sx, sy, size, 0, Math.PI * 2);
                    kingCtx.fill();
                }

                // Confetti
                for (let i = 0; i < 15; i++) {
                    const cx = (dangerTime * 30 + i * 40) % 220 - 10;
                    const cy = (dangerTime * 50 + i * 30) % 140 - 10;
                    kingCtx.fillStyle = ['#ff0', '#f0f', '#0ff', '#0f0', '#f00'][i % 5];
                    kingCtx.fillRect(cx, cy, 6, 6);
                }

                document.getElementById('dangerLabel').textContent = 'üëë KING SAVED! üëë';
                document.getElementById('dangerLabel').style.color = '#ffd700';
            }

            kingCtx.restore();
            requestAnimationFrame(drawKing);
        }

        function drawSword(x, y, scale) {
            kingCtx.save();
            kingCtx.translate(x, y);
            kingCtx.scale(scale, scale);

            // Blade
            const bladeGrad = kingCtx.createLinearGradient(0, 0, 15, 0);
            bladeGrad.addColorStop(0, '#ccc');
            bladeGrad.addColorStop(0.5, '#fff');
            bladeGrad.addColorStop(1, '#999');
            kingCtx.fillStyle = bladeGrad;
            kingCtx.beginPath();
            kingCtx.moveTo(7, 0);
            kingCtx.lineTo(15, 50);
            kingCtx.lineTo(7, 60);
            kingCtx.lineTo(0, 50);
            kingCtx.closePath();
            kingCtx.fill();

            // Handle
            kingCtx.fillStyle = '#8B4513';
            kingCtx.fillRect(2, -15, 12, 18);

            // Guard
            kingCtx.fillStyle = '#ffd700';
            kingCtx.fillRect(-5, -2, 25, 6);

            kingCtx.restore();
        }

        function drawMonster(x, y, flip = false, celebrating = false, attacking = false) {
            kingCtx.save();
            kingCtx.translate(x, y);
            if (flip) kingCtx.scale(-1, 1);

            // Attacking animation - arm raised
            if (attacking) {
                const armSwing = Math.sin(dangerTime * 8) * 15;
                kingCtx.fillStyle = '#4a0080';
                kingCtx.beginPath();
                kingCtx.moveTo(28, 15);
                kingCtx.lineTo(40 + armSwing, -5 + Math.abs(armSwing/2));
                kingCtx.lineTo(45 + armSwing, 0 + Math.abs(armSwing/2));
                kingCtx.lineTo(32, 20);
                kingCtx.closePath();
                kingCtx.fill();

                // Claws
                kingCtx.fillStyle = '#fff';
                kingCtx.beginPath();
                kingCtx.moveTo(40 + armSwing, -5);
                kingCtx.lineTo(48 + armSwing, -12);
                kingCtx.lineTo(43 + armSwing, -3);
                kingCtx.fill();
            }

            // Body
            kingCtx.fillStyle = '#4a0080';
            kingCtx.beginPath();
            kingCtx.arc(15, 20, 18, 0, Math.PI * 2);
            kingCtx.fill();

            // Eyes (glowing red, or happy if celebrating)
            if (celebrating) {
                // Happy curved eyes
                kingCtx.strokeStyle = '#ff0';
                kingCtx.lineWidth = 3;
                kingCtx.beginPath();
                kingCtx.arc(8, 15, 5, 0.2 * Math.PI, 0.8 * Math.PI);
                kingCtx.stroke();
                kingCtx.beginPath();
                kingCtx.arc(22, 15, 5, 0.2 * Math.PI, 0.8 * Math.PI);
                kingCtx.stroke();
            } else {
                kingCtx.fillStyle = '#ff0000';
                kingCtx.shadowColor = '#ff0000';
                kingCtx.shadowBlur = attacking ? 15 : 8;
                kingCtx.beginPath();
                kingCtx.arc(8, 15, attacking ? 5 : 4, 0, Math.PI * 2);
                kingCtx.arc(22, 15, attacking ? 5 : 4, 0, Math.PI * 2);
                kingCtx.fill();
                kingCtx.shadowBlur = 0;
            }

            // Mouth
            if (celebrating) {
                // Big happy smile
                kingCtx.fillStyle = '#300060';
                kingCtx.beginPath();
                kingCtx.arc(15, 28, 8, 0, Math.PI);
                kingCtx.fill();
                kingCtx.fillStyle = '#ff0';
                kingCtx.fillRect(11, 28, 3, 4);
                kingCtx.fillRect(16, 28, 3, 4);
            } else {
                // Teeth - more aggressive when attacking
                kingCtx.fillStyle = '#fff';
                const teethSize = attacking ? 10 : 7;
                kingCtx.beginPath();
                kingCtx.moveTo(5, 28);
                kingCtx.lineTo(8, 28 + teethSize);
                kingCtx.lineTo(11, 28);
                kingCtx.fill();
                kingCtx.beginPath();
                kingCtx.moveTo(12, 28);
                kingCtx.lineTo(15, 28 + teethSize - 2);
                kingCtx.lineTo(18, 28);
                kingCtx.fill();
                kingCtx.beginPath();
                kingCtx.moveTo(19, 28);
                kingCtx.lineTo(22, 28 + teethSize);
                kingCtx.lineTo(25, 28);
                kingCtx.fill();
            }

            // Horns
            kingCtx.fillStyle = '#2a0050';
            kingCtx.beginPath();
            kingCtx.moveTo(5, 8);
            kingCtx.lineTo(0, -8);
            kingCtx.lineTo(12, 5);
            kingCtx.closePath();
            kingCtx.fill();
            kingCtx.beginPath();
            kingCtx.moveTo(25, 8);
            kingCtx.lineTo(30, -8);
            kingCtx.lineTo(18, 5);
            kingCtx.closePath();
            kingCtx.fill();

            // Drool when attacking
            if (attacking) {
                kingCtx.fillStyle = '#8f8';
                kingCtx.beginPath();
                const droolY = 35 + Math.sin(dangerTime * 5) * 3;
                kingCtx.ellipse(10, droolY, 2, 4 + Math.sin(dangerTime * 3) * 2, 0, 0, Math.PI * 2);
                kingCtx.fill();
            }

            kingCtx.restore();
        }

        function drawKingCharacter(x, y, s, danger = 0, isRescued = false) {
            // Shake when scared
            const shakeX = !isRescued && danger > 0.5 ? Math.sin(dangerTime * 15) * danger * 3 : 0;

            // Body
            kingCtx.fillStyle = '#4169E1';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 14*s + shakeX, y + 35*s);
            kingCtx.lineTo(x - 17*s + shakeX, y + 8*s);
            kingCtx.lineTo(x + 17*s + shakeX, y + 8*s);
            kingCtx.lineTo(x + 14*s + shakeX, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();

            // Cape (fluttering when scared)
            kingCtx.fillStyle = '#DC143C';
            const capeWave = !isRescued ? Math.sin(dangerTime * 8) * 5 * danger : 0;
            kingCtx.beginPath();
            kingCtx.moveTo(x - 14*s + shakeX, y + 10*s);
            kingCtx.quadraticCurveTo(x - 24*s - capeWave + shakeX, y + 24*s, x - 17*s + shakeX, y + 38*s);
            kingCtx.lineTo(x - 12*s + shakeX, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();
            kingCtx.beginPath();
            kingCtx.moveTo(x + 14*s + shakeX, y + 10*s);
            kingCtx.quadraticCurveTo(x + 24*s + capeWave + shakeX, y + 24*s, x + 17*s + shakeX, y + 38*s);
            kingCtx.lineTo(x + 12*s + shakeX, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();

            // Arms raised in fear when danger is high
            if (!isRescued && danger > 0.6) {
                kingCtx.fillStyle = '#FFDAB9';
                // Left arm up
                kingCtx.beginPath();
                kingCtx.ellipse(x - 18*s + shakeX, y - 5*s, 4*s, 8*s, -0.3, 0, Math.PI * 2);
                kingCtx.fill();
                // Right arm up
                kingCtx.beginPath();
                kingCtx.ellipse(x + 18*s + shakeX, y - 5*s, 4*s, 8*s, 0.3, 0, Math.PI * 2);
                kingCtx.fill();
            }

            // Head
            kingCtx.fillStyle = '#FFDAB9';
            kingCtx.beginPath();
            kingCtx.arc(x + shakeX, y - 4*s, 14*s, 0, Math.PI * 2);
            kingCtx.fill();

            // Crown (tilted when scared)
            kingCtx.save();
            kingCtx.translate(x + shakeX, y - 11*s);
            if (!isRescued && danger > 0.3) {
                kingCtx.rotate(Math.sin(dangerTime * 10) * 0.1 * danger);
            }
            kingCtx.fillStyle = '#FFD700';
            kingCtx.beginPath();
            kingCtx.moveTo(-12*s, 0);
            kingCtx.lineTo(-10*s, -15*s);
            kingCtx.lineTo(-5*s, -7*s);
            kingCtx.lineTo(0, -18*s);
            kingCtx.lineTo(5*s, -7*s);
            kingCtx.lineTo(10*s, -15*s);
            kingCtx.lineTo(12*s, 0);
            kingCtx.closePath();
            kingCtx.fill();
            // Crown jewel
            kingCtx.fillStyle = '#FF0000';
            kingCtx.beginPath();
            kingCtx.arc(0, -9*s, 2.5*s, 0, Math.PI * 2);
            kingCtx.fill();
            kingCtx.restore();

            // Eyes based on fear level
            kingCtx.fillStyle = '#000';
            if (isRescued) {
                // Happy closed eyes
                kingCtx.strokeStyle = '#000';
                kingCtx.lineWidth = 2;
                kingCtx.beginPath();
                kingCtx.arc(x - 5*s + shakeX, y - 5*s, 4*s, 0.1 * Math.PI, 0.9 * Math.PI);
                kingCtx.stroke();
                kingCtx.beginPath();
                kingCtx.arc(x + 5*s + shakeX, y - 5*s, 4*s, 0.1 * Math.PI, 0.9 * Math.PI);
                kingCtx.stroke();
            } else {
                // Scared eyes - bigger when more danger
                const eyeSize = 2.5 + danger * 2;
                kingCtx.beginPath();
                kingCtx.arc(x - 5*s + shakeX, y - 5*s, eyeSize*s, 0, Math.PI * 2);
                kingCtx.arc(x + 5*s + shakeX, y - 5*s, eyeSize*s, 0, Math.PI * 2);
                kingCtx.fill();

                // White reflection (pupils dilated in fear)
                kingCtx.fillStyle = '#fff';
                kingCtx.beginPath();
                kingCtx.arc(x - 6*s + shakeX, y - 6*s, (1 + danger)*s, 0, Math.PI * 2);
                kingCtx.arc(x + 4*s + shakeX, y - 6*s, (1 + danger)*s, 0, Math.PI * 2);
                kingCtx.fill();

                // Worried eyebrows - more angled when more scared
                kingCtx.strokeStyle = '#000';
                kingCtx.lineWidth = 2;
                kingCtx.beginPath();
                kingCtx.moveTo(x - 10*s + shakeX, y - 12*s - danger * 3*s);
                kingCtx.lineTo(x - 2*s + shakeX, y - 10*s);
                kingCtx.moveTo(x + 10*s + shakeX, y - 12*s - danger * 3*s);
                kingCtx.lineTo(x + 2*s + shakeX, y - 10*s);
                kingCtx.stroke();
            }

            // Mouth
            if (isRescued) {
                // Big happy smile
                kingCtx.strokeStyle = '#000';
                kingCtx.lineWidth = 2;
                kingCtx.beginPath();
                kingCtx.arc(x + shakeX, y + 2*s, 7*s, 0.1 * Math.PI, 0.9 * Math.PI);
                kingCtx.stroke();
            } else {
                // Scared screaming mouth - bigger when more danger
                const mouthHeight = 5 + danger * 5;
                kingCtx.fillStyle = '#300';
                kingCtx.beginPath();
                kingCtx.ellipse(x + shakeX, y + 5*s, 5*s, mouthHeight*s, 0, 0, Math.PI * 2);
                kingCtx.fill();

                // Tongue if really scared
                if (danger > 0.7) {
                    kingCtx.fillStyle = '#c66';
                    kingCtx.beginPath();
                    kingCtx.ellipse(x + shakeX, y + 8*s, 3*s, 4*s, 0, 0, Math.PI);
                    kingCtx.fill();
                }
            }

            // Beard
            kingCtx.fillStyle = '#8B4513';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 8*s + shakeX, y + 4*s);
            kingCtx.quadraticCurveTo(x + shakeX, y + 18*s, x + 8*s + shakeX, y + 4*s);
            kingCtx.fill();

            // Sweat drops - more when more scared
            if (!isRescued) {
                kingCtx.fillStyle = '#87CEEB';
                const sweatCount = Math.floor(1 + danger * 3);
                for (let i = 0; i < sweatCount; i++) {
                    const sweatY = y - 2*s + Math.sin(dangerTime * 5 + i) * 3 + i * 8;
                    const sweatX = x + 13*s + shakeX + Math.sin(dangerTime * 3 + i * 2) * 2;
                    kingCtx.beginPath();
                    kingCtx.ellipse(sweatX, sweatY, 2*s, 3*s, 0, 0, Math.PI * 2);
                    kingCtx.fill();
                }
            }

            // Blush and sparkles when happy
            if (isRescued) {
                kingCtx.fillStyle = 'rgba(255, 150, 150, 0.5)';
                kingCtx.beginPath();
                kingCtx.arc(x - 10*s + shakeX, y, 3*s, 0, Math.PI * 2);
                kingCtx.arc(x + 10*s + shakeX, y, 3*s, 0, Math.PI * 2);
                kingCtx.fill();
            }
        }

        function setKingMood(mood, phrase) {
            kingMood = mood;
            // Mood is now shown through King's visual animations
        }

        function getRandomPhrase(category) {
            const phrases = kingPhrases[category];
            return phrases[Math.floor(Math.random() * phrases.length)];
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hazardAnimTime += 0.05;

            // Smooth hazard rise toward target level
            hazardLevel += (targetHazardLevel - hazardLevel) * 0.03;

            // Draw board background
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.roundRect(0, 0, canvas.width, canvas.height, 15);
            ctx.fill();

            // Draw grid cells
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const x = col * GEM_SIZE + BOARD_OFFSET;
                    const y = row * GEM_SIZE + BOARD_OFFSET;
                    ctx.fillStyle = (row + col) % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
                    ctx.fillRect(x, y, GEM_SIZE - 1, GEM_SIZE - 1);
                }
            }

            // Draw gems (only if not submerged in hazard)
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gem = grid[row][col];
                    const hazardRowStart = GRID_SIZE - Math.floor(hazardLevel);
                    if (gem && gem.type >= 0) {
                        // Gems in hazard are partially visible and sinking
                        if (row >= hazardRowStart) {
                            ctx.globalAlpha = 0.4;
                        }
                        drawGem(gem, row, col);
                        ctx.globalAlpha = 1;
                    }
                }
            }

            // Draw rising hazard from bottom
            if (hazardLevel > 0) {
                const hazardHeight = hazardLevel * GEM_SIZE + Math.sin(hazardAnimTime * 2) * 5;
                const hazardY = canvas.height - hazardHeight;

                if (hazardType === 'lava') {
                    // LAVA DRAWING
                    ctx.shadowColor = '#ff4500';
                    ctx.shadowBlur = 30;

                    const lavaGrad = ctx.createLinearGradient(0, hazardY, 0, canvas.height);
                    lavaGrad.addColorStop(0, 'rgba(255, 100, 0, 0.85)');
                    lavaGrad.addColorStop(0.3, 'rgba(255, 50, 0, 0.9)');
                    lavaGrad.addColorStop(1, 'rgba(139, 0, 0, 0.95)');
                    ctx.fillStyle = lavaGrad;

                    // Wavy lava surface
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    for (let x = 0; x <= canvas.width; x += 10) {
                        const waveY = hazardY + Math.sin(x * 0.05 + hazardAnimTime * 3) * 8 + Math.sin(x * 0.1 + hazardAnimTime * 2) * 4;
                        ctx.lineTo(x, waveY);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Lava bubbles
                    ctx.fillStyle = '#ff6600';
                    for (let i = 0; i < 8; i++) {
                        const bubbleX = (hazardAnimTime * 20 + i * 50) % canvas.width;
                        const bubbleY = hazardY + 10 + Math.sin(hazardAnimTime * 4 + i * 2) * 15;
                        const bubbleSize = 4 + Math.sin(hazardAnimTime * 3 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Bright spots
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.6)';
                    for (let i = 0; i < 5; i++) {
                        const spotX = (i * 80 + 20) + Math.sin(hazardAnimTime + i) * 10;
                        const spotY = hazardY + 15 + Math.sin(hazardAnimTime * 2 + i * 3) * 8;
                        ctx.beginPath();
                        ctx.ellipse(spotX, spotY, 15 + Math.sin(hazardAnimTime + i) * 5, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Ember particles
                    ctx.fillStyle = '#ffaa00';
                    for (let i = 0; i < 12; i++) {
                        const emberX = (i * 35 + hazardAnimTime * 15) % canvas.width;
                        const emberY = hazardY - ((hazardAnimTime * 50 + i * 20) % 60);
                        const emberSize = 2 + Math.random();
                        ctx.globalAlpha = 1 - ((hazardAnimTime * 50 + i * 20) % 60) / 60;
                        ctx.beginPath();
                        ctx.arc(emberX, emberY, emberSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;

                } else if (hazardType === 'water') {
                    // WATER DRAWING
                    ctx.shadowColor = '#00aaff';
                    ctx.shadowBlur = 20;

                    const waterGrad = ctx.createLinearGradient(0, hazardY, 0, canvas.height);
                    waterGrad.addColorStop(0, 'rgba(0, 150, 255, 0.7)');
                    waterGrad.addColorStop(0.3, 'rgba(0, 100, 200, 0.8)');
                    waterGrad.addColorStop(1, 'rgba(0, 50, 100, 0.9)');
                    ctx.fillStyle = waterGrad;

                    // Wavy water surface
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    for (let x = 0; x <= canvas.width; x += 8) {
                        const waveY = hazardY + Math.sin(x * 0.03 + hazardAnimTime * 2) * 6 + Math.sin(x * 0.07 + hazardAnimTime * 3) * 3;
                        ctx.lineTo(x, waveY);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Water shine/foam on surface
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < 6; i++) {
                        const foamX = (i * 70 + hazardAnimTime * 25) % (canvas.width + 50) - 25;
                        const foamY = hazardY + Math.sin(hazardAnimTime * 2 + i) * 4;
                        ctx.beginPath();
                        ctx.ellipse(foamX, foamY, 20 + Math.sin(hazardAnimTime + i) * 5, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Air bubbles rising
                    ctx.fillStyle = 'rgba(200, 230, 255, 0.6)';
                    for (let i = 0; i < 10; i++) {
                        const bubbleX = (i * 40 + 20) + Math.sin(hazardAnimTime * 2 + i * 3) * 8;
                        const bubbleY = canvas.height - ((hazardAnimTime * 40 + i * 35) % hazardHeight);
                        const bubbleSize = 3 + Math.sin(hazardAnimTime + i) * 1.5;
                        if (bubbleY > hazardY) {
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Fish swimming
                    for (let i = 0; i < 3; i++) {
                        const fishX = (hazardAnimTime * 30 + i * 150) % (canvas.width + 60) - 30;
                        const fishY = hazardY + 20 + i * 25 + Math.sin(hazardAnimTime * 3 + i) * 8;
                        const fishDir = i % 2 === 0 ? 1 : -1;

                        if (fishY < canvas.height - 10) {
                            ctx.save();
                            ctx.translate(fishX, fishY);
                            ctx.scale(fishDir, 1);

                            // Fish body
                            ctx.fillStyle = ['#ff9900', '#ff66aa', '#66ff66'][i];
                            ctx.beginPath();
                            ctx.ellipse(0, 0, 12, 6, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // Fish tail
                            ctx.beginPath();
                            ctx.moveTo(-10, 0);
                            ctx.lineTo(-18, -6);
                            ctx.lineTo(-18, 6);
                            ctx.closePath();
                            ctx.fill();

                            // Fish eye
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(6, -1, 2, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        }
                    }

                    // Splash droplets above water
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.7)';
                    for (let i = 0; i < 5; i++) {
                        const dropX = (i * 80 + 30) + Math.sin(hazardAnimTime * 4 + i * 2) * 10;
                        const dropY = hazardY - 5 - Math.abs(Math.sin(hazardAnimTime * 5 + i * 1.5)) * 15;
                        ctx.beginPath();
                        ctx.arc(dropX, dropY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                } else if (hazardType === 'quicksand') {
                    // QUICKSAND DRAWING
                    ctx.shadowColor = '#8B7355';
                    ctx.shadowBlur = 15;

                    const sandGrad = ctx.createLinearGradient(0, hazardY, 0, canvas.height);
                    sandGrad.addColorStop(0, 'rgba(210, 180, 140, 0.85)');
                    sandGrad.addColorStop(0.3, 'rgba(180, 140, 100, 0.9)');
                    sandGrad.addColorStop(1, 'rgba(120, 90, 60, 0.95)');
                    ctx.fillStyle = sandGrad;

                    // Slow wavy quicksand surface
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    for (let x = 0; x <= canvas.width; x += 12) {
                        const waveY = hazardY + Math.sin(x * 0.04 + hazardAnimTime * 0.8) * 4 + Math.sin(x * 0.08 + hazardAnimTime * 0.5) * 2;
                        ctx.lineTo(x, waveY);
                    }
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Swirling patterns in quicksand
                    ctx.strokeStyle = 'rgba(100, 70, 40, 0.4)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        const swirlX = (i * 100 + 50) + Math.sin(hazardAnimTime * 0.3 + i) * 20;
                        const swirlY = hazardY + 30 + i * 15;
                        if (swirlY < canvas.height - 10) {
                            ctx.beginPath();
                            for (let a = 0; a < Math.PI * 4; a += 0.2) {
                                const r = 5 + a * 2;
                                const sx = swirlX + Math.cos(a + hazardAnimTime * 0.5) * r;
                                const sy = swirlY + Math.sin(a + hazardAnimTime * 0.5) * r * 0.4;
                                if (a === 0) ctx.moveTo(sx, sy);
                                else ctx.lineTo(sx, sy);
                            }
                            ctx.stroke();
                        }
                    }

                    // Mud bubbles popping slowly
                    ctx.fillStyle = 'rgba(150, 120, 80, 0.7)';
                    for (let i = 0; i < 6; i++) {
                        const bubbleX = (i * 70 + 20) + Math.sin(hazardAnimTime * 0.5 + i * 2) * 15;
                        const bubbleY = hazardY + 8 + Math.sin(hazardAnimTime * 0.8 + i * 3) * 6;
                        const bubbleSize = 6 + Math.sin(hazardAnimTime * 0.6 + i) * 3;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                        // Bubble highlight
                        ctx.fillStyle = 'rgba(200, 170, 130, 0.5)';
                        ctx.beginPath();
                        ctx.arc(bubbleX - 2, bubbleY - 2, bubbleSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(150, 120, 80, 0.7)';
                    }

                    // Bones/skulls partially visible
                    ctx.fillStyle = '#e8e0d0';
                    // Skull
                    const skullX = 80 + Math.sin(hazardAnimTime * 0.2) * 5;
                    const skullY = hazardY + 25;
                    if (skullY < canvas.height - 20) {
                        ctx.beginPath();
                        ctx.arc(skullX, skullY, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(skullX - 3, skullY - 2, 2, 0, Math.PI * 2);
                        ctx.arc(skullX + 3, skullY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#e8e0d0';
                    }

                    // Bone sticking out
                    const boneX = 280 + Math.sin(hazardAnimTime * 0.3) * 3;
                    const boneY = hazardY + 15;
                    if (boneY < canvas.height - 15) {
                        ctx.save();
                        ctx.translate(boneX, boneY);
                        ctx.rotate(-0.3 + Math.sin(hazardAnimTime * 0.4) * 0.1);
                        ctx.fillRect(-2, -15, 4, 20);
                        ctx.beginPath();
                        ctx.arc(-3, -15, 4, 0, Math.PI * 2);
                        ctx.arc(3, -15, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }

                    // Hand reaching out
                    const handX = 180;
                    const handY = hazardY + 10 + Math.sin(hazardAnimTime * 1.5) * 5;
                    if (handY < canvas.height - 20) {
                        ctx.fillStyle = '#daa';
                        ctx.save();
                        ctx.translate(handX, handY);
                        // Palm
                        ctx.beginPath();
                        ctx.ellipse(0, 10, 8, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Fingers reaching up
                        for (let f = -2; f <= 2; f++) {
                            ctx.fillRect(f * 4 - 1.5, -8, 3, 18);
                        }
                        ctx.restore();
                    }

                    // Sandy dust particles floating up
                    ctx.fillStyle = 'rgba(210, 180, 140, 0.5)';
                    for (let i = 0; i < 8; i++) {
                        const dustX = (i * 50 + hazardAnimTime * 8) % canvas.width;
                        const dustY = hazardY - ((hazardAnimTime * 20 + i * 25) % 40);
                        const dustSize = 2 + Math.random();
                        ctx.globalAlpha = 0.6 - ((hazardAnimTime * 20 + i * 25) % 40) / 50;
                        ctx.beginPath();
                        ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            // Draw selection (only if not in hazard)
            if (selectedGem) {
                const hazardRowStart = GRID_SIZE - Math.floor(hazardLevel);
                if (selectedGem.row < hazardRowStart) {
                    const x = selectedGem.col * GEM_SIZE + BOARD_OFFSET;
                    const y = selectedGem.row * GEM_SIZE + BOARD_OFFSET;
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x + 2, y + 2, GEM_SIZE - 5, GEM_SIZE - 5);
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(x + 2, y + 2, GEM_SIZE - 5, GEM_SIZE - 5);
                    ctx.shadowBlur = 0;
                }
            }

            // Draw particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life > 0) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
            particles = particles.filter(p => p.life > 0);

            // Draw floating texts
            floatingTexts.forEach(t => {
                t.y -= 1.5;
                t.life -= 0.02;
                if (t.life > 0) {
                    ctx.globalAlpha = t.life;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+' + t.value, t.x, t.y);
                    ctx.globalAlpha = 1;
                }
            });
            floatingTexts = floatingTexts.filter(t => t.life > 0);

            requestAnimationFrame(draw);
        }

        function drawGem(gem, row, col) {
            const gemType = GEM_TYPES[gem.type];
            const x = gem.x + GEM_SIZE / 2;
            const y = gem.y + GEM_SIZE / 2;
            const size = (GEM_SIZE - PADDING * 2) / 2 * gem.scale;

            ctx.save();
            ctx.translate(x, y);

            const gradient = ctx.createRadialGradient(-size/3, -size/3, 0, 0, 0, size);
            gradient.addColorStop(0, gemType.gradient[0]);
            gradient.addColorStop(1, gemType.gradient[1]);
            ctx.fillStyle = gradient;

            ctx.beginPath();
            switch (gemType.shape) {
                case 'diamond':
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    break;
                case 'circle':
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.roundRect(-size, -size, size * 2, size * 2, 6);
                    break;
                case 'triangle':
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, size * 0.7);
                    ctx.lineTo(-size, size * 0.7);
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
                        const px = Math.cos(angle) * size;
                        const py = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'star':
                    for (let i = 0; i < 5; i++) {
                        const outerAngle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const innerAngle = outerAngle + Math.PI / 5;
                        const outerX = Math.cos(outerAngle) * size;
                        const outerY = Math.sin(outerAngle) * size;
                        const innerX = Math.cos(innerAngle) * size * 0.5;
                        const innerY = Math.sin(innerAngle) * size * 0.5;
                        if (i === 0) ctx.moveTo(outerX, outerY);
                        else ctx.lineTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                    }
                    break;
            }
            ctx.closePath();
            ctx.fill();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.ellipse(-size/4, -size/4, size/3, size/5, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();

            // Special indicators
            if (gem.special === 'bomb') {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üí•', 0, 0);
            } else if (gem.special === 'lightning') {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ö°', 0, 0);
            }

            ctx.restore();
        }

        function getGridPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            const col = Math.floor((x - BOARD_OFFSET) / GEM_SIZE);
            const row = Math.floor((y - BOARD_OFFSET) / GEM_SIZE);
            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                return { row, col };
            }
            return null;
        }

        function handleClick(clientX, clientY) {
            if (animating || moves <= 0) return;
            const pos = getGridPosition(clientX, clientY);
            if (!pos) return;

            // Can't select gems in hazard
            const hazardRowStart = GRID_SIZE - Math.floor(hazardLevel);
            if (pos.row >= hazardRowStart) return;

            if (selectedGem) {
                // Can't swap with gems in hazard
                if (selectedGem.row >= hazardRowStart) {
                    selectedGem = null;
                    return;
                }

                const rowDiff = Math.abs(selectedGem.row - pos.row);
                const colDiff = Math.abs(selectedGem.col - pos.col);
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    trySwap(selectedGem.row, selectedGem.col, pos.row, pos.col);
                    selectedGem = null;
                } else if (selectedGem.row === pos.row && selectedGem.col === pos.col) {
                    selectedGem = null;
                } else {
                    selectedGem = pos;
                }
            } else {
                selectedGem = pos;
            }
        }

        async function trySwap(row1, col1, row2, col2) {
            animating = true;
            const temp = grid[row1][col1];
            grid[row1][col1] = grid[row2][col2];
            grid[row2][col2] = temp;
            await animateSwap(row1, col1, row2, col2);

            const matches = findMatches();
            if (matches.length > 0) {
                moves--;
                updateUI();
                await processMatches(matches);
            } else {
                // Bad swap - hazard rises!
                targetHazardLevel = Math.min(GRID_SIZE, targetHazardLevel + 1);

                // Swap back
                const temp = grid[row1][col1];
                grid[row1][col1] = grid[row2][col2];
                grid[row2][col2] = temp;
                await animateSwap(row1, col1, row2, col2);
            }
            animating = false;
            checkGameState();
        }

        function animateSwap(row1, col1, row2, col2) {
            return new Promise(resolve => {
                const gem1 = grid[row1][col1];
                const gem2 = grid[row2][col2];
                const targetX1 = col1 * GEM_SIZE + BOARD_OFFSET;
                const targetY1 = row1 * GEM_SIZE + BOARD_OFFSET;
                const targetX2 = col2 * GEM_SIZE + BOARD_OFFSET;
                const targetY2 = row2 * GEM_SIZE + BOARD_OFFSET;
                let progress = 0;
                const startX1 = gem1.x, startY1 = gem1.y;
                const startX2 = gem2.x, startY2 = gem2.y;

                function animate() {
                    progress += 0.12;
                    if (progress >= 1) {
                        gem1.x = targetX1; gem1.y = targetY1;
                        gem2.x = targetX2; gem2.y = targetY2;
                        resolve();
                        return;
                    }
                    const ease = 1 - Math.pow(1 - progress, 3);
                    gem1.x = startX1 + (targetX1 - startX1) * ease;
                    gem1.y = startY1 + (targetY1 - startY1) * ease;
                    gem2.x = startX2 + (targetX2 - startX2) * ease;
                    gem2.y = startY2 + (targetY2 - startY2) * ease;
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function findMatches() {
            const matches = [];
            const checked = new Set();

            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const type = grid[row][col].type;

                    let hMatch = [{ row, col }];
                    for (let c = col + 1; c < GRID_SIZE && grid[row][c].type === type; c++) {
                        hMatch.push({ row, col: c });
                    }
                    if (hMatch.length >= 3) {
                        const key = hMatch.map(p => `${p.row},${p.col}`).sort().join('|');
                        if (!checked.has(key)) {
                            checked.add(key);
                            matches.push(hMatch);
                        }
                    }

                    let vMatch = [{ row, col }];
                    for (let r = row + 1; r < GRID_SIZE && grid[r][col].type === type; r++) {
                        vMatch.push({ row: r, col });
                    }
                    if (vMatch.length >= 3) {
                        const key = vMatch.map(p => `${p.row},${p.col}`).sort().join('|');
                        if (!checked.has(key)) {
                            checked.add(key);
                            matches.push(vMatch);
                        }
                    }
                }
            }
            return matches;
        }

        async function processMatches(matches) {
            let combo = 1;

            while (matches.length > 0) {
                let matchScore = 0;
                const allMatched = new Set();

                matches.forEach(match => {
                    match.forEach(pos => {
                        allMatched.add(`${pos.row},${pos.col}`);
                    });
                    const baseScore = 50;
                    const lengthBonus = (match.length - 3) * 25;
                    matchScore += (baseScore + lengthBonus) * combo;

                    if (match.length === 4) {
                        const midIndex = Math.floor(match.length / 2);
                        const specialPos = match[midIndex];
                        grid[specialPos.row][specialPos.col].special = 'lightning';
                    } else if (match.length >= 5) {
                        const midIndex = Math.floor(match.length / 2);
                        const specialPos = match[midIndex];
                        grid[specialPos.row][specialPos.col].special = 'bomb';
                    }
                });

                score += matchScore;
                updateUI();

                // Update king mood
                if (combo >= 3) {
                    setKingMood('excited', getRandomPhrase('combo'));
                } else if (matches.some(m => m.length >= 4)) {
                    setKingMood('excited', getRandomPhrase('bigMatch'));
                } else {
                    setKingMood('happy', getRandomPhrase('match'));
                }

                // Particles
                allMatched.forEach(key => {
                    const [row, col] = key.split(',').map(Number);
                    const gem = grid[row][col];
                    const gemType = GEM_TYPES[gem.type];
                    for (let i = 0; i < 6; i++) {
                        particles.push({
                            x: gem.x + GEM_SIZE / 2,
                            y: gem.y + GEM_SIZE / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8 - 3,
                            color: gemType.color,
                            size: Math.random() * 5 + 2,
                            life: 1
                        });
                    }
                });

                if (combo > 1) {
                    floatingTexts.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        value: `${combo}x COMBO!`,
                        life: 1.5
                    });
                }

                floatingTexts.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2 + 25,
                    value: matchScore,
                    life: 1
                });

                await animateRemoval(allMatched);
                await dropGems();
                await fillNewGems();

                matches = findMatches();
                combo++;
            }

            lastCombo = combo - 1;

            // Reset king mood after a delay
            setTimeout(() => {
                if (moves <= 5 && score < targetScore) {
                    setKingMood('worried', getRandomPhrase('lowMoves'));
                } else {
                    setKingMood('normal', "Keep matching!");
                }
            }, 1500);
        }

        function animateRemoval(matchedSet) {
            return new Promise(resolve => {
                let progress = 0;
                function animate() {
                    progress += 0.1;
                    matchedSet.forEach(key => {
                        const [row, col] = key.split(',').map(Number);
                        if (grid[row][col]) {
                            grid[row][col].scale = 1 - progress;
                        }
                    });
                    if (progress >= 1) {
                        matchedSet.forEach(key => {
                            const [row, col] = key.split(',').map(Number);
                            if (grid[row][col] && !grid[row][col].special) {
                                grid[row][col].type = -1;
                            } else if (grid[row][col] && grid[row][col].special) {
                                grid[row][col].scale = 1;
                                grid[row][col].special = null;
                            }
                        });
                        resolve();
                        return;
                    }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function dropGems() {
            return new Promise(resolve => {
                let dropping = false;
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyRow = GRID_SIZE - 1;
                    for (let row = GRID_SIZE - 1; row >= 0; row--) {
                        if (grid[row][col].type >= 0) {
                            if (row !== emptyRow) {
                                grid[emptyRow][col] = grid[row][col];
                                grid[row][col] = { type: -1, x: col * GEM_SIZE + BOARD_OFFSET, y: row * GEM_SIZE + BOARD_OFFSET, scale: 1 };
                                grid[emptyRow][col].targetY = emptyRow * GEM_SIZE + BOARD_OFFSET;
                                dropping = true;
                            }
                            emptyRow--;
                        }
                    }
                }
                if (!dropping) { resolve(); return; }

                function animate() {
                    let stillDropping = false;
                    for (let row = 0; row < GRID_SIZE; row++) {
                        for (let col = 0; col < GRID_SIZE; col++) {
                            const gem = grid[row][col];
                            if (gem.type >= 0 && gem.y < gem.targetY) {
                                gem.y += (gem.targetY - gem.y) * 0.3 + 2;
                                if (gem.y > gem.targetY) gem.y = gem.targetY;
                                else stillDropping = true;
                            }
                        }
                    }
                    if (!stillDropping) { resolve(); return; }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function fillNewGems() {
            return new Promise(resolve => {
                let newGems = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyCount = 0;
                    for (let row = 0; row < GRID_SIZE; row++) {
                        if (grid[row][col].type < 0) {
                            emptyCount++;
                            grid[row][col] = {
                                type: Math.floor(Math.random() * GEM_TYPES.length),
                                x: col * GEM_SIZE + BOARD_OFFSET,
                                y: -emptyCount * GEM_SIZE + BOARD_OFFSET,
                                targetY: row * GEM_SIZE + BOARD_OFFSET,
                                scale: 1,
                                special: null
                            };
                            newGems.push(grid[row][col]);
                        }
                    }
                }
                if (newGems.length === 0) { resolve(); return; }

                function animate() {
                    let stillFalling = false;
                    newGems.forEach(gem => {
                        if (gem.y < gem.targetY) {
                            gem.y += (gem.targetY - gem.y) * 0.25 + 3;
                            if (gem.y > gem.targetY) gem.y = gem.targetY;
                            else stillFalling = true;
                        }
                    });
                    if (!stillFalling) { resolve(); return; }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('moves').textContent = moves;
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = targetScore;

            // Update rescue progress bar
            const progress = Math.min(100, (score / targetScore) * 100);
            document.getElementById('rescueProgress').style.width = progress + '%';
        }

        function checkGameState() {
            if (score >= targetScore) {
                rescued = true;
                kingDead = false;
                setKingMood('excited', getRandomPhrase('win'));
                const stars = score >= targetScore * 2 ? '‚≠ê‚≠ê‚≠ê' :
                             score >= targetScore * 1.5 ? '‚≠ê‚≠ê' : '‚≠ê';
                document.getElementById('stars').textContent = stars;
                document.getElementById('levelScore').textContent = `Score: ${score}`;
                setTimeout(() => {
                    document.getElementById('levelComplete').classList.add('show');
                }, 500);
            } else if (moves <= 0 || targetHazardLevel >= GRID_SIZE) {
                // King dies from hazard or out of moves!
                kingDead = true;
                rescued = false;
                setKingMood('worried', getRandomPhrase('lose'));
                setTimeout(() => {
                    document.getElementById('loseOverlay').classList.add('show');
                }, 1500);
            }
        }

        function nextLevel() {
            document.getElementById('levelComplete').classList.remove('show');
            document.getElementById('loseOverlay').classList.remove('show');
            level++;
            targetScore = 1000 + (level - 1) * 500;
            moves = Math.max(15, 25 - level);
            maxMoves = moves;
            score = 0;
            rescued = false;
            kingDead = false;
            hazardLevel = 0;
            targetHazardLevel = 0;
            // Cycle through lava, water, quicksand
            const hazards = ['lava', 'water', 'quicksand'];
            hazardType = hazards[(level - 1) % 3];
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        function resetLevel() {
            document.getElementById('levelComplete').classList.remove('show');
            document.getElementById('loseOverlay').classList.remove('show');
            moves = Math.max(15, 25 - level + 1);
            maxMoves = moves;
            score = 0;
            rescued = false;
            kingDead = false;
            hazardLevel = 0;
            targetHazardLevel = 0;
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        function newGame() {
            document.getElementById('levelComplete').classList.remove('show');
            document.getElementById('loseOverlay').classList.remove('show');
            level = 1;
            targetScore = 1000;
            moves = 20;
            maxMoves = 20;
            score = 0;
            rescued = false;
            kingDead = false;
            hazardLevel = 0;
            targetHazardLevel = 0;
            // Random hazard each new game
            const hazards = ['lava', 'water', 'quicksand'];
            hazardType = hazards[Math.floor(Math.random() * hazards.length)];
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        // Events
        canvas.addEventListener('click', (e) => handleClick(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleClick(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Start
        init();
        draw();
    </script>
</body>
</html>
