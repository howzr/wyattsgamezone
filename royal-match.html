<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Royal Match">
    <title>Royal Match - Help The King!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #1a0a3e 0%, #2d1b69 50%, #1a0a3e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        h1 {
            color: #ffd700;
            font-size: 1.8em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-info {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .info-box {
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 8px 20px;
            text-align: center;
            min-width: 100px;
        }

        .info-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .king-panel {
            background: linear-gradient(180deg, rgba(60,30,30,0.9), rgba(30,15,15,0.9));
            border: 3px solid #8B0000;
            border-radius: 15px;
            padding: 10px;
            position: relative;
            box-shadow: 0 0 20px rgba(255,0,0,0.3), inset 0 0 30px rgba(0,0,0,0.5);
        }

        .king-panel canvas {
            border-radius: 10px;
            display: block;
        }

        .danger-label {
            color: #ff4444;
            font-size: 0.8em;
            text-align: center;
            margin-top: 5px;
            text-shadow: 0 0 10px #ff0000;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .rescue-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 8px;
        }

        .rescue-progress {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff9500);
            width: 0%;
            transition: width 0.3s;
            border-radius: 5px;
            box-shadow: 0 0 10px #ffd700;
        }

        #gameCanvas {
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.5), inset 0 0 60px rgba(0,0,0,0.3);
            background: linear-gradient(180deg, #2a1a5e, #1a0a3e);
            touch-action: none;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(180deg, #ffd700, #ff9500);
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            color: #1a0a3e;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            min-height: 50px;
            touch-action: manipulation;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .btn.secondary {
            background: linear-gradient(180deg, #8a2be2, #6a1bb2);
            color: #fff;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .level-complete {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        .level-complete.show {
            display: flex;
        }

        .level-complete h2 {
            color: #ffd700;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .level-complete p {
            color: #fff;
            font-size: 1.3em;
            margin-bottom: 20px;
        }

        .stars {
            font-size: 3em;
            margin-bottom: 20px;
        }

        @media (max-width: 450px) {
            h1 { font-size: 1.3em; }
            .info-box { padding: 6px 12px; min-width: 70px; }
            .info-value { font-size: 1em; }
            .king-speech { font-size: 0.8em; min-width: 120px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üëë Royal Match üëë</h1>
    </div>

    <div class="game-info">
        <div class="info-box">
            <div class="info-label">Level</div>
            <div class="info-value" id="level">1</div>
        </div>
        <div class="info-box">
            <div class="info-label">Score</div>
            <div class="info-value" id="score">0</div>
        </div>
        <div class="info-box">
            <div class="info-label">Moves</div>
            <div class="info-value" id="moves">20</div>
        </div>
        <div class="info-box">
            <div class="info-label">Target</div>
            <div class="info-value" id="target">1000</div>
        </div>
    </div>

    <div class="game-area">
        <div class="king-panel">
            <canvas id="kingCanvas" width="200" height="120"></canvas>
            <div class="danger-label" id="dangerLabel">‚ö†Ô∏è DANGER! Save the King! ‚ö†Ô∏è</div>
            <div class="rescue-bar"><div class="rescue-progress" id="rescueProgress"></div></div>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <div class="buttons">
        <button class="btn" onclick="resetLevel()">Restart</button>
        <button class="btn secondary" onclick="newGame()">New Game</button>
    </div>

    <div class="level-complete" id="levelComplete">
        <h2>üëë King Rescued! üëë</h2>
        <div class="stars" id="stars">‚≠ê‚≠ê‚≠ê</div>
        <p id="levelScore">Score: 0</p>
        <button class="btn" onclick="nextLevel()">Save Next King!</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const kingCanvas = document.getElementById('kingCanvas');
        const kingCtx = kingCanvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 8;
        const GEM_SIZE = 48;
        const PADDING = 4;
        const BOARD_OFFSET = 8;

        // Gem types
        const GEM_TYPES = [
            { color: '#ff4757', gradient: ['#ff6b7a', '#ff2f44'], shape: 'diamond' },
            { color: '#2ed573', gradient: ['#5fe094', '#1fb854'], shape: 'circle' },
            { color: '#3498db', gradient: ['#5dade2', '#2980b9'], shape: 'square' },
            { color: '#f39c12', gradient: ['#f5b041', '#d68910'], shape: 'triangle' },
            { color: '#9b59b6', gradient: ['#af7ac5', '#7d3c98'], shape: 'hexagon' },
            { color: '#1abc9c', gradient: ['#48c9b0', '#17a589'], shape: 'star' }
        ];

        // Game state
        let grid = [];
        let selectedGem = null;
        let score = 0;
        let moves = 20;
        let level = 1;
        let targetScore = 1000;
        let animating = false;
        let particles = [];
        let floatingTexts = [];
        let kingMood = 'normal'; // normal, happy, excited, worried
        let lastCombo = 0;

        // King expressions
        const kingPhrases = {
            start: ["Help! I'm trapped!", "Free me!", "Match to rescue me!"],
            match: ["Keep going!", "Almost there!", "You can do it!"],
            combo: ["Amazing!", "I feel hope!", "The bars shake!"],
            bigMatch: ["Incredible!", "I see light!", "Freedom awaits!"],
            lowMoves: ["Hurry please!", "Not much time!", "I'm scared!"],
            win: ["I'm FREE!", "Thank you!", "My hero!"],
            lose: ["Oh no...", "Try again!", "Don't give up!"]
        };

        function init() {
            createGrid();
            removeInitialMatches();
            drawKing();
            draw();
        }

        function createGrid() {
            grid = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                grid[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    grid[row][col] = {
                        type: Math.floor(Math.random() * GEM_TYPES.length),
                        x: col * GEM_SIZE + BOARD_OFFSET,
                        y: row * GEM_SIZE + BOARD_OFFSET,
                        targetY: row * GEM_SIZE + BOARD_OFFSET,
                        scale: 1,
                        special: null
                    };
                }
            }
        }

        function removeInitialMatches() {
            let hasMatches = true;
            while (hasMatches) {
                hasMatches = false;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (checkMatchAt(row, col)) {
                            grid[row][col].type = Math.floor(Math.random() * GEM_TYPES.length);
                            hasMatches = true;
                        }
                    }
                }
            }
        }

        function checkMatchAt(row, col) {
            const type = grid[row][col].type;
            let hCount = 1;
            for (let c = col - 1; c >= 0 && grid[row][c].type === type; c--) hCount++;
            for (let c = col + 1; c < GRID_SIZE && grid[row][c].type === type; c++) hCount++;
            let vCount = 1;
            for (let r = row - 1; r >= 0 && grid[r][col].type === type; r--) vCount++;
            for (let r = row + 1; r < GRID_SIZE && grid[r][col].type === type; r++) vCount++;
            return hCount >= 3 || vCount >= 3;
        }

        let rescued = false;
        let dangerTime = 0;
        let swordY = -30;
        let monsterX = -40;
        let lavaHeight = 0;
        let spikeY = -20;

        function drawKing() {
            kingCtx.clearRect(0, 0, kingCanvas.width, kingCanvas.height);
            dangerTime += 0.05;

            // Dark dungeon background
            const bgGrad = kingCtx.createLinearGradient(0, 0, 0, kingCanvas.height);
            bgGrad.addColorStop(0, '#1a1a2a');
            bgGrad.addColorStop(1, '#0a0a15');
            kingCtx.fillStyle = bgGrad;
            kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);

            // Stone wall texture
            kingCtx.fillStyle = '#333';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 5; j++) {
                    kingCtx.fillRect(i * 26 + (j % 2) * 13, j * 26, 24, 24);
                }
            }

            const kingX = kingCanvas.width / 2;
            const kingY = 75;

            if (!rescued) {
                // Animate dangers based on how close to losing
                const danger = 1 - Math.min(1, score / targetScore);

                // Rising lava from bottom
                lavaHeight = 25 * danger + Math.sin(dangerTime * 2) * 3;
                const lavaGrad = kingCtx.createLinearGradient(0, kingCanvas.height - lavaHeight, 0, kingCanvas.height);
                lavaGrad.addColorStop(0, '#ff4500');
                lavaGrad.addColorStop(0.5, '#ff0000');
                lavaGrad.addColorStop(1, '#8B0000');
                kingCtx.fillStyle = lavaGrad;
                kingCtx.fillRect(0, kingCanvas.height - lavaHeight, kingCanvas.width, lavaHeight);

                // Lava bubbles
                kingCtx.fillStyle = '#ff6600';
                for (let i = 0; i < 5; i++) {
                    const bx = 20 + i * 40 + Math.sin(dangerTime + i) * 5;
                    const by = kingCanvas.height - lavaHeight + Math.sin(dangerTime * 3 + i) * 5;
                    kingCtx.beginPath();
                    kingCtx.arc(bx, by, 4 + Math.sin(dangerTime + i) * 2, 0, Math.PI * 2);
                    kingCtx.fill();
                }

                // Falling swords from top
                swordY = -10 + (30 * danger) + Math.sin(dangerTime * 1.5) * 8;
                drawSword(30, swordY, 0.8);
                drawSword(170, swordY + 10, 0.8);

                // Spikes from ceiling
                spikeY = -5 + (20 * danger) + Math.sin(dangerTime * 2) * 5;
                kingCtx.fillStyle = '#666';
                for (let i = 0; i < 7; i++) {
                    kingCtx.beginPath();
                    kingCtx.moveTo(i * 30 + 15, spikeY);
                    kingCtx.lineTo(i * 30 + 25, spikeY + 25);
                    kingCtx.lineTo(i * 30 + 5, spikeY + 25);
                    kingCtx.closePath();
                    kingCtx.fill();
                }
                // Spike shine
                kingCtx.fillStyle = '#888';
                for (let i = 0; i < 7; i++) {
                    kingCtx.beginPath();
                    kingCtx.moveTo(i * 30 + 15, spikeY);
                    kingCtx.lineTo(i * 30 + 18, spikeY + 15);
                    kingCtx.lineTo(i * 30 + 12, spikeY + 15);
                    kingCtx.closePath();
                    kingCtx.fill();
                }

                // Monster approaching from left
                monsterX = -20 + (50 * danger) + Math.sin(dangerTime) * 5;
                drawMonster(monsterX, 60);

                // Monster approaching from right
                drawMonster(kingCanvas.width - monsterX - 30, 70, true);
            }

            // Draw the King
            drawKingCharacter(kingX, kingY, 0.6);

            if (rescued) {
                // Victory glow
                kingCtx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.sin(dangerTime * 3) * 0.1})`;
                kingCtx.fillRect(0, 0, kingCanvas.width, kingCanvas.height);

                // Sparkles
                kingCtx.fillStyle = '#fff';
                for (let i = 0; i < 8; i++) {
                    const sx = Math.sin(dangerTime + i * 0.8) * 80 + 100;
                    const sy = Math.cos(dangerTime + i * 0.8) * 40 + 60;
                    kingCtx.beginPath();
                    kingCtx.arc(sx, sy, 2, 0, Math.PI * 2);
                    kingCtx.fill();
                }

                document.getElementById('dangerLabel').textContent = '‚ú® KING SAVED! ‚ú®';
                document.getElementById('dangerLabel').style.color = '#ffd700';
            } else {
                document.getElementById('dangerLabel').textContent = '‚ö†Ô∏è DANGER! Save the King! ‚ö†Ô∏è';
                document.getElementById('dangerLabel').style.color = '#ff4444';
            }

            requestAnimationFrame(drawKing);
        }

        function drawSword(x, y, scale) {
            kingCtx.save();
            kingCtx.translate(x, y);
            kingCtx.scale(scale, scale);

            // Blade
            const bladeGrad = kingCtx.createLinearGradient(0, 0, 15, 0);
            bladeGrad.addColorStop(0, '#ccc');
            bladeGrad.addColorStop(0.5, '#fff');
            bladeGrad.addColorStop(1, '#999');
            kingCtx.fillStyle = bladeGrad;
            kingCtx.beginPath();
            kingCtx.moveTo(7, 0);
            kingCtx.lineTo(15, 50);
            kingCtx.lineTo(7, 60);
            kingCtx.lineTo(0, 50);
            kingCtx.closePath();
            kingCtx.fill();

            // Handle
            kingCtx.fillStyle = '#8B4513';
            kingCtx.fillRect(2, -15, 12, 18);

            // Guard
            kingCtx.fillStyle = '#ffd700';
            kingCtx.fillRect(-5, -2, 25, 6);

            kingCtx.restore();
        }

        function drawMonster(x, y, flip = false) {
            kingCtx.save();
            kingCtx.translate(x, y);
            if (flip) kingCtx.scale(-1, 1);

            // Body
            kingCtx.fillStyle = '#4a0080';
            kingCtx.beginPath();
            kingCtx.arc(15, 20, 18, 0, Math.PI * 2);
            kingCtx.fill();

            // Eyes (glowing red)
            kingCtx.fillStyle = '#ff0000';
            kingCtx.shadowColor = '#ff0000';
            kingCtx.shadowBlur = 8;
            kingCtx.beginPath();
            kingCtx.arc(8, 15, 4, 0, Math.PI * 2);
            kingCtx.arc(22, 15, 4, 0, Math.PI * 2);
            kingCtx.fill();
            kingCtx.shadowBlur = 0;

            // Teeth
            kingCtx.fillStyle = '#fff';
            kingCtx.beginPath();
            kingCtx.moveTo(5, 28);
            kingCtx.lineTo(8, 35);
            kingCtx.lineTo(11, 28);
            kingCtx.fill();
            kingCtx.beginPath();
            kingCtx.moveTo(19, 28);
            kingCtx.lineTo(22, 35);
            kingCtx.lineTo(25, 28);
            kingCtx.fill();

            // Horns
            kingCtx.fillStyle = '#2a0050';
            kingCtx.beginPath();
            kingCtx.moveTo(5, 8);
            kingCtx.lineTo(0, -8);
            kingCtx.lineTo(12, 5);
            kingCtx.closePath();
            kingCtx.fill();
            kingCtx.beginPath();
            kingCtx.moveTo(25, 8);
            kingCtx.lineTo(30, -8);
            kingCtx.lineTo(18, 5);
            kingCtx.closePath();
            kingCtx.fill();

            kingCtx.restore();
        }

        function drawKingCharacter(x, y, s) {
            // Body
            kingCtx.fillStyle = '#4169E1';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 14*s, y + 35*s);
            kingCtx.lineTo(x - 17*s, y + 8*s);
            kingCtx.lineTo(x + 17*s, y + 8*s);
            kingCtx.lineTo(x + 14*s, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();

            // Cape
            kingCtx.fillStyle = '#DC143C';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 14*s, y + 10*s);
            kingCtx.quadraticCurveTo(x - 24*s, y + 24*s, x - 17*s, y + 38*s);
            kingCtx.lineTo(x - 12*s, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();
            kingCtx.beginPath();
            kingCtx.moveTo(x + 14*s, y + 10*s);
            kingCtx.quadraticCurveTo(x + 24*s, y + 24*s, x + 17*s, y + 38*s);
            kingCtx.lineTo(x + 12*s, y + 35*s);
            kingCtx.closePath();
            kingCtx.fill();

            // Head
            kingCtx.fillStyle = '#FFDAB9';
            kingCtx.beginPath();
            kingCtx.arc(x, y - 4*s, 14*s, 0, Math.PI * 2);
            kingCtx.fill();

            // Crown
            kingCtx.fillStyle = '#FFD700';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 12*s, y - 11*s);
            kingCtx.lineTo(x - 10*s, y - 26*s);
            kingCtx.lineTo(x - 5*s, y - 18*s);
            kingCtx.lineTo(x, y - 29*s);
            kingCtx.lineTo(x + 5*s, y - 18*s);
            kingCtx.lineTo(x + 10*s, y - 26*s);
            kingCtx.lineTo(x + 12*s, y - 11*s);
            kingCtx.closePath();
            kingCtx.fill();

            // Crown jewel
            kingCtx.fillStyle = '#FF0000';
            kingCtx.beginPath();
            kingCtx.arc(x, y - 20*s, 2.5*s, 0, Math.PI * 2);
            kingCtx.fill();

            // Eyes - always worried when in danger
            kingCtx.fillStyle = '#000';
            if (rescued) {
                // Happy eyes
                kingCtx.beginPath();
                kingCtx.arc(x - 5*s, y - 5*s, 2.5*s, 0, Math.PI * 2);
                kingCtx.arc(x + 5*s, y - 5*s, 2.5*s, 0, Math.PI * 2);
                kingCtx.fill();
            } else {
                // Scared eyes (wide)
                kingCtx.beginPath();
                kingCtx.arc(x - 5*s, y - 5*s, 3.5*s, 0, Math.PI * 2);
                kingCtx.arc(x + 5*s, y - 5*s, 3.5*s, 0, Math.PI * 2);
                kingCtx.fill();
                kingCtx.fillStyle = '#fff';
                kingCtx.beginPath();
                kingCtx.arc(x - 6*s, y - 6*s, 1.5*s, 0, Math.PI * 2);
                kingCtx.arc(x + 4*s, y - 6*s, 1.5*s, 0, Math.PI * 2);
                kingCtx.fill();
                // Worried eyebrows
                kingCtx.strokeStyle = '#000';
                kingCtx.lineWidth = 2;
                kingCtx.beginPath();
                kingCtx.moveTo(x - 9*s, y - 12*s);
                kingCtx.lineTo(x - 2*s, y - 10*s);
                kingCtx.moveTo(x + 9*s, y - 12*s);
                kingCtx.lineTo(x + 2*s, y - 10*s);
                kingCtx.stroke();
            }

            // Mouth
            kingCtx.strokeStyle = '#000';
            kingCtx.lineWidth = 2;
            kingCtx.beginPath();
            if (rescued) {
                kingCtx.arc(x, y + 2*s, 6*s, 0.1 * Math.PI, 0.9 * Math.PI);
            } else {
                // Scared open mouth
                kingCtx.fillStyle = '#000';
                kingCtx.beginPath();
                kingCtx.ellipse(x, y + 5*s, 5*s, 7*s, 0, 0, Math.PI * 2);
                kingCtx.fill();
            }
            kingCtx.stroke();

            // Beard
            kingCtx.fillStyle = '#8B4513';
            kingCtx.beginPath();
            kingCtx.moveTo(x - 8*s, y + 4*s);
            kingCtx.quadraticCurveTo(x, y + 18*s, x + 8*s, y + 4*s);
            kingCtx.fill();

            // Sweat drops when scared
            if (!rescued) {
                kingCtx.fillStyle = '#87CEEB';
                kingCtx.beginPath();
                kingCtx.ellipse(x + 12*s, y - 2*s + Math.sin(dangerTime * 5) * 2, 2*s, 3*s, 0, 0, Math.PI * 2);
                kingCtx.fill();
            }

            // Blush when happy
            if (rescued) {
                kingCtx.fillStyle = 'rgba(255, 150, 150, 0.5)';
                kingCtx.beginPath();
                kingCtx.arc(x - 10*s, y, 3*s, 0, Math.PI * 2);
                kingCtx.arc(x + 10*s, y, 3*s, 0, Math.PI * 2);
                kingCtx.fill();
            }
        }

        function setKingMood(mood, phrase) {
            kingMood = mood;
            if (phrase) {
                document.getElementById('kingSpeech').textContent = phrase;
            }
        }

        function getRandomPhrase(category) {
            const phrases = kingPhrases[category];
            return phrases[Math.floor(Math.random() * phrases.length)];
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw board background
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.roundRect(0, 0, canvas.width, canvas.height, 15);
            ctx.fill();

            // Draw grid cells
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const x = col * GEM_SIZE + BOARD_OFFSET;
                    const y = row * GEM_SIZE + BOARD_OFFSET;
                    ctx.fillStyle = (row + col) % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
                    ctx.fillRect(x, y, GEM_SIZE - 1, GEM_SIZE - 1);
                }
            }

            // Draw gems
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gem = grid[row][col];
                    if (gem && gem.type >= 0) {
                        drawGem(gem, row, col);
                    }
                }
            }

            // Draw selection
            if (selectedGem) {
                const x = selectedGem.col * GEM_SIZE + BOARD_OFFSET;
                const y = selectedGem.row * GEM_SIZE + BOARD_OFFSET;
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + 2, y + 2, GEM_SIZE - 5, GEM_SIZE - 5);
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
                ctx.strokeRect(x + 2, y + 2, GEM_SIZE - 5, GEM_SIZE - 5);
                ctx.shadowBlur = 0;
            }

            // Draw particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life > 0) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
            particles = particles.filter(p => p.life > 0);

            // Draw floating texts
            floatingTexts.forEach(t => {
                t.y -= 1.5;
                t.life -= 0.02;
                if (t.life > 0) {
                    ctx.globalAlpha = t.life;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+' + t.value, t.x, t.y);
                    ctx.globalAlpha = 1;
                }
            });
            floatingTexts = floatingTexts.filter(t => t.life > 0);

            requestAnimationFrame(draw);
        }

        function drawGem(gem, row, col) {
            const gemType = GEM_TYPES[gem.type];
            const x = gem.x + GEM_SIZE / 2;
            const y = gem.y + GEM_SIZE / 2;
            const size = (GEM_SIZE - PADDING * 2) / 2 * gem.scale;

            ctx.save();
            ctx.translate(x, y);

            const gradient = ctx.createRadialGradient(-size/3, -size/3, 0, 0, 0, size);
            gradient.addColorStop(0, gemType.gradient[0]);
            gradient.addColorStop(1, gemType.gradient[1]);
            ctx.fillStyle = gradient;

            ctx.beginPath();
            switch (gemType.shape) {
                case 'diamond':
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    break;
                case 'circle':
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.roundRect(-size, -size, size * 2, size * 2, 6);
                    break;
                case 'triangle':
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, size * 0.7);
                    ctx.lineTo(-size, size * 0.7);
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
                        const px = Math.cos(angle) * size;
                        const py = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'star':
                    for (let i = 0; i < 5; i++) {
                        const outerAngle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const innerAngle = outerAngle + Math.PI / 5;
                        const outerX = Math.cos(outerAngle) * size;
                        const outerY = Math.sin(outerAngle) * size;
                        const innerX = Math.cos(innerAngle) * size * 0.5;
                        const innerY = Math.sin(innerAngle) * size * 0.5;
                        if (i === 0) ctx.moveTo(outerX, outerY);
                        else ctx.lineTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                    }
                    break;
            }
            ctx.closePath();
            ctx.fill();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.ellipse(-size/4, -size/4, size/3, size/5, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();

            // Special indicators
            if (gem.special === 'bomb') {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üí•', 0, 0);
            } else if (gem.special === 'lightning') {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ö°', 0, 0);
            }

            ctx.restore();
        }

        function getGridPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            const col = Math.floor((x - BOARD_OFFSET) / GEM_SIZE);
            const row = Math.floor((y - BOARD_OFFSET) / GEM_SIZE);
            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                return { row, col };
            }
            return null;
        }

        function handleClick(clientX, clientY) {
            if (animating || moves <= 0) return;
            const pos = getGridPosition(clientX, clientY);
            if (!pos) return;

            if (selectedGem) {
                const rowDiff = Math.abs(selectedGem.row - pos.row);
                const colDiff = Math.abs(selectedGem.col - pos.col);
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    trySwap(selectedGem.row, selectedGem.col, pos.row, pos.col);
                    selectedGem = null;
                } else if (selectedGem.row === pos.row && selectedGem.col === pos.col) {
                    selectedGem = null;
                } else {
                    selectedGem = pos;
                }
            } else {
                selectedGem = pos;
            }
        }

        async function trySwap(row1, col1, row2, col2) {
            animating = true;
            const temp = grid[row1][col1];
            grid[row1][col1] = grid[row2][col2];
            grid[row2][col2] = temp;
            await animateSwap(row1, col1, row2, col2);

            const matches = findMatches();
            if (matches.length > 0) {
                moves--;
                updateUI();
                await processMatches(matches);
            } else {
                const temp = grid[row1][col1];
                grid[row1][col1] = grid[row2][col2];
                grid[row2][col2] = temp;
                await animateSwap(row1, col1, row2, col2);
            }
            animating = false;
            checkGameState();
        }

        function animateSwap(row1, col1, row2, col2) {
            return new Promise(resolve => {
                const gem1 = grid[row1][col1];
                const gem2 = grid[row2][col2];
                const targetX1 = col1 * GEM_SIZE + BOARD_OFFSET;
                const targetY1 = row1 * GEM_SIZE + BOARD_OFFSET;
                const targetX2 = col2 * GEM_SIZE + BOARD_OFFSET;
                const targetY2 = row2 * GEM_SIZE + BOARD_OFFSET;
                let progress = 0;
                const startX1 = gem1.x, startY1 = gem1.y;
                const startX2 = gem2.x, startY2 = gem2.y;

                function animate() {
                    progress += 0.12;
                    if (progress >= 1) {
                        gem1.x = targetX1; gem1.y = targetY1;
                        gem2.x = targetX2; gem2.y = targetY2;
                        resolve();
                        return;
                    }
                    const ease = 1 - Math.pow(1 - progress, 3);
                    gem1.x = startX1 + (targetX1 - startX1) * ease;
                    gem1.y = startY1 + (targetY1 - startY1) * ease;
                    gem2.x = startX2 + (targetX2 - startX2) * ease;
                    gem2.y = startY2 + (targetY2 - startY2) * ease;
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function findMatches() {
            const matches = [];
            const checked = new Set();

            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const type = grid[row][col].type;

                    let hMatch = [{ row, col }];
                    for (let c = col + 1; c < GRID_SIZE && grid[row][c].type === type; c++) {
                        hMatch.push({ row, col: c });
                    }
                    if (hMatch.length >= 3) {
                        const key = hMatch.map(p => `${p.row},${p.col}`).sort().join('|');
                        if (!checked.has(key)) {
                            checked.add(key);
                            matches.push(hMatch);
                        }
                    }

                    let vMatch = [{ row, col }];
                    for (let r = row + 1; r < GRID_SIZE && grid[r][col].type === type; r++) {
                        vMatch.push({ row: r, col });
                    }
                    if (vMatch.length >= 3) {
                        const key = vMatch.map(p => `${p.row},${p.col}`).sort().join('|');
                        if (!checked.has(key)) {
                            checked.add(key);
                            matches.push(vMatch);
                        }
                    }
                }
            }
            return matches;
        }

        async function processMatches(matches) {
            let combo = 1;

            while (matches.length > 0) {
                let matchScore = 0;
                const allMatched = new Set();

                matches.forEach(match => {
                    match.forEach(pos => {
                        allMatched.add(`${pos.row},${pos.col}`);
                    });
                    const baseScore = 50;
                    const lengthBonus = (match.length - 3) * 25;
                    matchScore += (baseScore + lengthBonus) * combo;

                    if (match.length === 4) {
                        const midIndex = Math.floor(match.length / 2);
                        const specialPos = match[midIndex];
                        grid[specialPos.row][specialPos.col].special = 'lightning';
                    } else if (match.length >= 5) {
                        const midIndex = Math.floor(match.length / 2);
                        const specialPos = match[midIndex];
                        grid[specialPos.row][specialPos.col].special = 'bomb';
                    }
                });

                score += matchScore;
                updateUI();

                // Update king mood
                if (combo >= 3) {
                    setKingMood('excited', getRandomPhrase('combo'));
                } else if (matches.some(m => m.length >= 4)) {
                    setKingMood('excited', getRandomPhrase('bigMatch'));
                } else {
                    setKingMood('happy', getRandomPhrase('match'));
                }

                // Particles
                allMatched.forEach(key => {
                    const [row, col] = key.split(',').map(Number);
                    const gem = grid[row][col];
                    const gemType = GEM_TYPES[gem.type];
                    for (let i = 0; i < 6; i++) {
                        particles.push({
                            x: gem.x + GEM_SIZE / 2,
                            y: gem.y + GEM_SIZE / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8 - 3,
                            color: gemType.color,
                            size: Math.random() * 5 + 2,
                            life: 1
                        });
                    }
                });

                if (combo > 1) {
                    floatingTexts.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        value: `${combo}x COMBO!`,
                        life: 1.5
                    });
                }

                floatingTexts.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2 + 25,
                    value: matchScore,
                    life: 1
                });

                await animateRemoval(allMatched);
                await dropGems();
                await fillNewGems();

                matches = findMatches();
                combo++;
            }

            lastCombo = combo - 1;

            // Reset king mood after a delay
            setTimeout(() => {
                if (moves <= 5 && score < targetScore) {
                    setKingMood('worried', getRandomPhrase('lowMoves'));
                } else {
                    setKingMood('normal', "Keep matching!");
                }
            }, 1500);
        }

        function animateRemoval(matchedSet) {
            return new Promise(resolve => {
                let progress = 0;
                function animate() {
                    progress += 0.1;
                    matchedSet.forEach(key => {
                        const [row, col] = key.split(',').map(Number);
                        if (grid[row][col]) {
                            grid[row][col].scale = 1 - progress;
                        }
                    });
                    if (progress >= 1) {
                        matchedSet.forEach(key => {
                            const [row, col] = key.split(',').map(Number);
                            if (grid[row][col] && !grid[row][col].special) {
                                grid[row][col].type = -1;
                            } else if (grid[row][col] && grid[row][col].special) {
                                grid[row][col].scale = 1;
                                grid[row][col].special = null;
                            }
                        });
                        resolve();
                        return;
                    }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function dropGems() {
            return new Promise(resolve => {
                let dropping = false;
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyRow = GRID_SIZE - 1;
                    for (let row = GRID_SIZE - 1; row >= 0; row--) {
                        if (grid[row][col].type >= 0) {
                            if (row !== emptyRow) {
                                grid[emptyRow][col] = grid[row][col];
                                grid[row][col] = { type: -1, x: col * GEM_SIZE + BOARD_OFFSET, y: row * GEM_SIZE + BOARD_OFFSET, scale: 1 };
                                grid[emptyRow][col].targetY = emptyRow * GEM_SIZE + BOARD_OFFSET;
                                dropping = true;
                            }
                            emptyRow--;
                        }
                    }
                }
                if (!dropping) { resolve(); return; }

                function animate() {
                    let stillDropping = false;
                    for (let row = 0; row < GRID_SIZE; row++) {
                        for (let col = 0; col < GRID_SIZE; col++) {
                            const gem = grid[row][col];
                            if (gem.type >= 0 && gem.y < gem.targetY) {
                                gem.y += (gem.targetY - gem.y) * 0.3 + 2;
                                if (gem.y > gem.targetY) gem.y = gem.targetY;
                                else stillDropping = true;
                            }
                        }
                    }
                    if (!stillDropping) { resolve(); return; }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function fillNewGems() {
            return new Promise(resolve => {
                let newGems = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    let emptyCount = 0;
                    for (let row = 0; row < GRID_SIZE; row++) {
                        if (grid[row][col].type < 0) {
                            emptyCount++;
                            grid[row][col] = {
                                type: Math.floor(Math.random() * GEM_TYPES.length),
                                x: col * GEM_SIZE + BOARD_OFFSET,
                                y: -emptyCount * GEM_SIZE + BOARD_OFFSET,
                                targetY: row * GEM_SIZE + BOARD_OFFSET,
                                scale: 1,
                                special: null
                            };
                            newGems.push(grid[row][col]);
                        }
                    }
                }
                if (newGems.length === 0) { resolve(); return; }

                function animate() {
                    let stillFalling = false;
                    newGems.forEach(gem => {
                        if (gem.y < gem.targetY) {
                            gem.y += (gem.targetY - gem.y) * 0.25 + 3;
                            if (gem.y > gem.targetY) gem.y = gem.targetY;
                            else stillFalling = true;
                        }
                    });
                    if (!stillFalling) { resolve(); return; }
                    requestAnimationFrame(animate);
                }
                animate();
            });
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('moves').textContent = moves;
            document.getElementById('level').textContent = level;
            document.getElementById('target').textContent = targetScore;

            // Update rescue progress bar
            const progress = Math.min(100, (score / targetScore) * 100);
            document.getElementById('rescueProgress').style.width = progress + '%';
        }

        function checkGameState() {
            if (score >= targetScore) {
                rescued = true;
                setKingMood('excited', getRandomPhrase('win'));
                const stars = score >= targetScore * 2 ? '‚≠ê‚≠ê‚≠ê' :
                             score >= targetScore * 1.5 ? '‚≠ê‚≠ê' : '‚≠ê';
                document.getElementById('stars').textContent = stars;
                document.getElementById('levelScore').textContent = `Score: ${score}`;
                setTimeout(() => {
                    document.getElementById('levelComplete').classList.add('show');
                }, 500);
            } else if (moves <= 0) {
                setKingMood('worried', getRandomPhrase('lose'));
            }
        }

        function nextLevel() {
            document.getElementById('levelComplete').classList.remove('show');
            level++;
            targetScore = 1000 + (level - 1) * 500;
            moves = Math.max(15, 25 - level);
            score = 0;
            rescued = false;
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        function resetLevel() {
            moves = Math.max(15, 25 - level + 1);
            score = 0;
            rescued = false;
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        function newGame() {
            document.getElementById('levelComplete').classList.remove('show');
            level = 1;
            targetScore = 1000;
            moves = 20;
            score = 0;
            rescued = false;
            createGrid();
            removeInitialMatches();
            updateUI();
            setKingMood('worried', getRandomPhrase('start'));
        }

        // Events
        canvas.addEventListener('click', (e) => handleClick(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleClick(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Start
        init();
        draw();
    </script>
</body>
</html>
